<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BOMB　BUSTERS</title>
<style>
  :root{
    --card-w:24px; --card-h:40px; --card-gap:3px;
    --char-w:40px; --char-h:60px;
    --item-w:50px; --item-h:75px;
    --di-w:70px; --di-h:70px;
    /* テーブルの見えている枠は固定。内部だけ広げる */
    --table-h:96px; --header-h:8px;
    --content-h: calc(var(--table-h) - var(--header-h) - 6px);
    --content-extra: 18px;
    --font-card:16px; --font-weight:bold;
  }

  *,*::before,*::after{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.75}
  .bold{font-weight:700}

  main{padding:10px 12px;display:flex;gap:12px; overflow:visible;}
  .col{flex:1;min-width:0; overflow:visible;}
  .side{width:38%;max-width:420px}

  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px}
  .btn{padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer}
  .btn.primary{background:#111;color:#fff;border-color:#111}
  .btn.small{padding:6px 10px;font-size:12px}
  .btn.big{padding:12px 14px;font-size:16px}
  .btn.ghost{background:transparent}
  .hidden{display:none!important}

  .fab{position:fixed;right:12px;bottom:12px;width:48px;height:48px;border-radius:50%;display:grid;place-items:center;background:#111;color:#fff;cursor:pointer;z-index:10}
  .menu{position:fixed;right:12px;bottom:64px;display:flex;flex-direction:column;gap:6px;background:#fff;border:1px solid #eee;border-radius:10px;padding:8px;box-shadow:0 12px 24px rgba(0,0,0,.08);z-index:11}
  .menu .btn{width:220px;text-align:left}

  /* ★ ホスト左下の工具ボタン */
  .host-tool{position:fixed;left:12px;bottom:12px;width:48px;height:48px;border-radius:50%;display:grid;place-items:center;background:#111;color:#fff;cursor:pointer;z-index:10}

  .items-bar{display:flex;align-items:center;gap:8px;margin-top:0}
  .items{display:flex;gap:6px;align-items:center;overflow-x:auto}
  .item{
    position:relative; width:var(--item-w);height:var(--item-h);
    border:1px solid #ddd;border-radius:8px;background:#fff;
    background-size:cover;background-position:center;cursor:pointer;flex:0 0 auto
  }
  .item.used{background:#fff url('./itemback.jpg') center/cover no-repeat}


  .di{ margin-left:auto;width:var(--di-w);height:var(--di-h);border-radius:10px;border:1px solid #ddd;background:#fff;
    background-size:cover;background-position:center;cursor:pointer;flex:0 0 auto }

  .tables{display:flex;flex-direction:column;gap:8px;margin-top:6px;overflow:visible;position:relative;}
  .table{
    position:relative;border:1px dashed #ddd;border-radius:10px;
    padding:0 8px;height:var(--table-h);display:block;background:#fff;
    overflow:auto;width:max-content;z-index:0;
  }
  .table.elevated{ z-index:9999; }

  .t-header{height:var(--header-h);display:flex;align-items:center;gap:6px;font-size:12px;margin-top:0;}
  .title{text-decoration:underline;padding-right:4px}

  .t-content{
    position:absolute;left:8px;right:8px;top:calc(var(--header-h) + 2px);bottom:calc(4px - var(--content-extra));
    display:flex;gap:8px;align-items:flex-start;min-height:var(--content-h);overflow:visible;
  }

  .char-card{
    width:var(--char-w);height:var(--char-h);background-size:cover;background-position:center;border-radius:6px;border:1px solid #ddd;
    cursor:pointer;user-select:none;flex:0 0 auto;
  }
  .char-card.blank{background:#f3f4f6;border:1px dashed #d1d5db;cursor:default;}

  .hand{
    display:flex;align-items:flex-start;gap:var(--card-gap);
    overflow-y:visible; overflow-x:visible;
    flex:0 0 auto;position:relative;
    max-height:calc(var(--content-h) - 2px + var(--content-extra));
    padding-bottom:2px;
  }

  .card-wrap{position:relative;width:var(--card-w);min-height:calc(var(--card-h) + 36px);flex:0 0 auto;}
  .card{
    width:var(--card-w);height:var(--card-h);border-radius:6px;border:1px solid #ddd;position:absolute;left:0;top:0;
    background:#bbb;display:flex;align-items:flex-start;justify-content:center;cursor:pointer;user-select:none
  }
  .card.back{background:#fff url('./codeback.jpg') center/cover no-repeat;border-color:#ccc}
  .card.open{background:#000}
  /* ★ アイテム2：選択可能カードの青枠 */
  .card.i2-selectable{outline:2px dashed #38bdf8; outline-offset:-1px;}

  .num{position:absolute;top:2px;left:0;right:0;text-align:center;font-size:var(--font-card);font-weight:var(--font-weight);color:#fff;line-height:1;text-shadow:0 1px 0 rgba(0,0,0,.15)}
  .img-bottom{position:absolute;left:1px;right:1px;bottom:1px;height:18px;border-radius:0 0 6px 6px;background-size:cover;background-position:center}

  .badge-fixed{position:absolute;left:0;right:0;top:calc(var(--card-h) + 2px);display:flex;flex-direction:column;align-items:center;z-index:10000;pointer-events:auto;}
  .alpha{width:var(--card-w);text-align:center;font-size:11px;user-select:none;line-height:1;background:#6b21a8;color:#fff;border:1px solid #4c1d95;border-radius:6px;padding:2px 0;cursor:pointer}
  .tok-col{display:flex;flex-direction:column;gap:2px;margin-top:2px}
  .token{font-size:11px;border-radius:4px;padding:1px 4px;line-height:1}
  /* ▼▼ 変更1：＝ と ≠ の色を入れ替え ▼▼ */
  .token.equal{background:#e5e7eb;color:#000}   /* 以前の≠色（グレー）を＝へ */
  .token.black{background:#000;color:#fff}
  .token.x1{background:#fce7f3;color:#000}
  .token.noteq{background:#ffedd5;color:#000}   /* 以前の＝色（薄オレンジ）を≠へ */
  /* ▲▲ 変更1ここまで ▲▲ */

  .marker,.blink{
    position:absolute;left:0;right:0;top:-12px;
    text-align:center;font-size:14px;line-height:1;
    z-index:12000; pointer-events:none;
  }
  .blink{ animation: blink 0.6s linear infinite; }
  @keyframes blink{ 0%,100%{opacity:0} 50%{opacity:1} }

  .pop-layer{ position:fixed;inset:0;z-index:2147483647;pointer-events:none; }
  .mini-pop{
    position:fixed;z-index:2147483647;background:#fff;border:1px solid #eee;border-radius:8px;padding:6px;box-shadow:0 8px 20px rgba(0,0,0,.08);
    display:flex;gap:6px;pointer-events:auto;flex-wrap:wrap;max-width:min(90vw,320px)
  }
  .bottom-pop{left:50%;transform:translateX(-50%);bottom:10px;}

  /* ★ 画面下部のグローバル黒枠バッジ（アイテム16表示） */
  .global-reveal{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:2147483647;}
  .global-reveal .token{cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,.12);}

  /* 追加：アイテム16のサイド表示 */
  .i16-side{
    position:absolute; left:calc(100% + 6px); top:50%; transform:translateY(-50%);
    z-index:2147483000;
  }

/* 追加：アイテム16の黒トークンをカードの真下に表示 */
.i16-below{
  position:absolute;
  left:50%;
  top:calc(100% + 4px);
  transform:translateX(-50%);
  z-index:2147483000;
}

/* 追加：アイテム16使用時はカード本体を上に持ち上げる */
.i16-lift{
  transform: translateY(-18px);
}
    
  .panel{display:flex;flex-direction:column;gap:10px}
  .list{border:1px solid #eee;border-radius:10px;padding:8px}
  .list h3{margin:0 0 6px 0;font-size:13px}
  .name{padding:4px 6px;border-radius:6px}
  .muted{opacity:.6}
  .mission{border:1px solid #eee;border-radius:10px;padding:10px}
  .mission h3{margin:0 0 8px 0;font-size:14px}

  .mission-footer{margin-top:12px;border-top:1px solid #eee;padding-top:8px}
  .mission-footer .line{font-size:13px;line-height:1.5}
  .mission-footer .line + .line{margin-top:4px}

  .restart-pop,.start-pop{
    position:fixed;left:50%;top:50%;transform:translate(-50%, -50%);
    background:#fff;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:14px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px
  }
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:#fff;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px
  }
  .start-pop .row,.seat-pop .row{display:flex;gap:8px;align-items:center}
  .start-pop label,.seat-pop label{width:84px;font-size:13px}
  .start-pop select{flex:1;padding:8px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .restart-actions{display:flex;gap:8px;align-items:center}
  .restart-actions .btn:first-child{font-size:11px;padding:4px 8px}
  .restart-actions .btn.big{flex:1}

  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none}
  .tab.active{background:#111;color:#fff;border-color:#111}
  .tab.disabled{opacity:.35;pointer-events:none}

  @media (max-width: 860px){
    main{flex-direction:column}
    .side{width:100%;max-width:none}
  }
</style>
</head>
<body>
<header>
  <h1>BOMB　BUSTERS</h1>
  <div class="small" id="roomInfo"></div>
</header>

<main>
  <div class="col">
    <div class="join-box" id="joinBox">
      <input id="roomCode" placeholder="ルームコード" maxlength="12" />
      <button class="btn primary" id="btnJoin">参加で入室</button>
      <button class="btn ghost" id="btnRandom">コード作成</button>
      <span class="small">入室後、右下の歯車から席を決められます</span>
    </div>

    <div id="lobby" class="hidden">
      <div class="row" style="display:flex;gap:8px;align-items:center;margin-top:4px">
        <button class="btn primary" id="btnStart" title="ホストのみ">爆弾を解除！</button>
        <span class="small" id="startHint">（ホストのみ押せます）</span>
      </div>

      <div class="items-bar hidden" id="itemsBar">
        <div class="items" id="items"></div>
        <div class="di" id="di"></div>
      </div>

      <div class="tables" id="tables"></div>

      <div id="missionFooter" class="mission-footer hidden">
        <div id="missionDetailTitle" class="bold line"></div>
        <div id="missionDetailBody"></div>
      </div>

      <button class="fab hidden" id="gear" title="設定">⚙</button>
      <div class="menu hidden" id="menuPopup">
        <button class="btn" id="btnSit">席に座る</button>
        <button class="btn" id="btnLeaveSeat">席を立つ</button>
        <button class="btn" id="btnRestart">やり直す</button>
      </div>
    </div>
  </div>

  <div class="col side">
    <div class="panel">
      <div class="list" id="listsBox">
        <h3>参加者</h3><div id="players"></div>
        <h3 style="margin-top:10px">観戦者</h3><div id="spectators"></div>
      </div>
      <div class="mission" id="missionBox">
        <h3>ミッション</h3>
        <div id="missionTitle" class="bold">（未選択）</div>
        <div id="missionText" class="small">開始時に人数と一緒に選びます</div>
      </div>
    </div>
  </div>
</main>

<div id="miniPop" class="mini-pop hidden"></div>
<div id="popLayer" class="pop-layer"></div>
<!-- ★ アイテム16の表示先（画面下部） -->
<div id="globalReveal" class="global-reveal hidden"></div>
<!-- ★ ホスト左下 工具アイコン -->
<button id="hostTool" class="host-tool hidden" title="工具">🔧</button>

<div id="restartPop" class="restart-pop hidden">
  <div style="font-size:14px">やり直しますか？</div>
  <div class="restart-actions">
    <button class="btn" id="btnRestartOk">やり直す</button>
    <button class="btn big" id="btnRestartCancel">キャンセル</button>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="row"><label>人数</label>
    <select id="selCount"><option>2</option><option>3</option><option selected>4</option><option>5</option><option>6</option></select>
  </div>
  <div class="row"><label>ミッション</label>
    <select id="selMission">
      <option value="1">#1 爆弾（赤コード）</option><option value="2">#2 黄コード</option><option value="3">#3 さらい爆弾</option>
      <option value="4">#4</option><option value="5">#5</option><option value="6">#6</option><option value="7">#7</option>
      <option value="8">#8</option><option value="9">#9</option><option value="10">#10</option>
      <option value="42">#42</option><option value="43">#43</option>
    </select>
  </div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small" id="btnStartOk">OK</button>
    <button class="btn small ghost" id="btnStartCancel">キャンセル</button>
  </div>
</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">閉じる</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, get, set, update, remove, onValue, onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* Firebase */
const firebaseConfig = {
  apiKey: "AIzaSyBpSx_lEcg1j9ExMJsVl5lBqAxOCfmFmSnI",
  authDomain: "chat-68c4c.firebaseapp.com",
  databaseURL: "https://chat-68c4c-default-rtdb.firebaseio.com",
  projectId: "chat-68c4c",
  storageBucket: "chat-68c4c.appspot.com",
  messagingSenderId: "172284325975",
  appId: "1:172284325975:web:6f9bdd77e822c0ea39dd92"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

/* State */
const state = {
  roomCode:null, userId:crypto.randomUUID(), userName:hiragana3(),
  isHost:false, mode:null, gameStarted:false, seatedTable:null, watching:null, seatPick:null
};

/* Elements */
const roomInfo = document.getElementById('roomInfo');
const joinBox= document.getElementById('joinBox');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const btnRandom=document.getElementById('btnRandom');

const lobby   = document.getElementById('lobby');
const btnStart= document.getElementById('btnStart');
const startHint=document.getElementById('startHint');

const itemsBar= document.getElementById('itemsBar');
const itemsEl = document.getElementById('items');
const diEl    = document.getElementById('di');

const tablesEl= document.getElementById('tables');
const gear    = document.getElementById('gear');
const menuPop = document.getElementById('menuPopup');
const btnSit  = document.getElementById('btnSit');
const btnLeave= document.getElementById('btnLeaveSeat');
const btnRestart=document.getElementById('btnRestart');
const restartPop=document.getElementById('restartPop');
const btnRestartOk=document.getElementById('btnRestartOk');
const btnRestartCancel=document.getElementById('btnRestartCancel');

const playersEl=document.getElementById('players');
const specsEl  =document.getElementById('spectators');
const listsBox =document.getElementById('listsBox');

const miniPop = document.getElementById('miniPop');

const startPop=document.getElementById('startPop');
const selCount=document.getElementById('selCount');
const selMission=document.getElementById('selMission');
const btnStartOk=document.getElementById('btnStartOk');
const btnStartCancel=document.getElementById('btnStartCancel');

const missionTitle=document.getElementById('missionTitle');
const missionText =document.getElementById('missionText');
const missionBox  =document.getElementById('missionBox');

const missionFooter = document.getElementById('missionFooter');
const missionDetailTitle = document.getElementById('missionDetailTitle');
const missionDetailBody  = document.getElementById('missionDetailBody');

const seatPop = document.getElementById('seatPop');
const seatTabs= document.getElementById('seatTabs');
const btnSeatCancel=document.getElementById('btnSeatCancel');

/* Pop layer */
const popLayer = document.getElementById('popLayer');
/* global reveal */
const globalReveal = document.getElementById('globalReveal');
/* host tool */
const hostTool = document.getElementById('hostTool');

/* helpers */
function hiragana3(){ const h=[..."あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん"]; return Array.from({length:3},()=>h[Math.random()*h.length|0]).join(''); }
const H=(el,b)=> el.classList.toggle('hidden', !!b);
function pos(el,x,y){el.style.left=x+'px';el.style.top=y+'px';}
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]]}return a}
function cssNum(name){const v=getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return parseFloat(v.replace('px',''))||0;}
const now=()=>Date.now();

/* pop positioning */
function placeInsideViewport(div, x, y){
  popLayer.appendChild(div);
  const pad = 8;
  pos(div, x + 6, y + 6);
  let r = div.getBoundingClientRect();
  if (r.right > innerWidth - pad){ const nx = Math.max(pad, x - r.width - 6); pos(div, nx, y + 6); r = div.getBoundingClientRect(); }
  if (r.left < pad) pos(div, pad, r.top);
  if (r.top < pad) pos(div, r.left, pad);
  if (r.bottom > innerHeight - pad) pos(div, r.left, Math.max(pad, innerHeight - r.height - pad));
}
function openOneMini(x,y,label,cb){
  const div=document.createElement('div'); div.className='mini-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  const b=document.createElement('button'); b.className='btn small'; b.textContent=label;
  b.onclick=()=>{ if(div.isConnected) div.remove(); cb&&cb(); };
  div.appendChild(b); placeInsideViewport(div,x,y);
}
function openMenu(x,y, entries){
  const div=document.createElement('div'); div.className='mini-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  entries.forEach(ent=>{ const b=document.createElement('button'); b.className='btn small'; b.textContent=ent.label; b.onclick=async ()=>{ if(div.isConnected) div.remove(); await ent.action?.(); }; div.appendChild(b); });
  placeInsideViewport(div, x, y);
}
function openBottomMenu(entries){
  const div=document.createElement('div'); div.className='mini-pop bottom-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  entries.forEach(ent=>{ const b=document.createElement('button'); b.className='btn small'; b.textContent=ent.label; b.onclick=async ()=>{ if(div.isConnected) div.remove(); await ent.action?.(); }; div.appendChild(b); });
  popLayer.appendChild(div);
}

/* enter */
btnRandom.onclick = ()=>{ inputCode.value = String(Math.random()*1e4|0).padStart(4,'0'); };
btnJoin.onclick   = ()=> enter('player');

async function enter(mode){
  const code=(inputCode.value||"").trim();
  if(!code){ alert('コードを入力してください'); return; }
  state.roomCode = code; state.mode=mode;

  const roomRef = ref(db, `rooms/${code}`);
  const snap=await get(roomRef);
  if(!snap.exists()){ state.isHost=true; await set(roomRef, baseRoom(state.userId)); }
  else{ state.isHost = snap.val()?.hostId === state.userId; }

  await set(ref(db, `rooms/${code}/players/${state.userId}`), {name:state.userName, at:Date.now()});
  onDisconnect(ref(db, `rooms/${code}/players/${state.userId}`)).remove();
  listenRoom(code);

  H(joinBox,true); H(lobby,false); H(gear,false); updateHeaderInfo();
}
function updateHeaderInfo(){ roomInfo.textContent = state.roomCode ? `コード：${state.roomCode}　/　あなた：${state.userName}` : ''; }

/* room base */
function baseRoom(hostId){
  return { createdAt: Date.now(), hostId, started:false, tableCount:0, tables:[], items:[], di:{value:0,max:6}, captainTable:null, mission:null,
    players:{}, spectators:{},
    meta:{ itemUses:{i1:0,i2:0,i12:0,i14:0}, tokenCounts:{equal:0,noteq:0,x1:0}, i2Flow:null, i18Flow:null, i16Badge:null } };
}

/* watch */
function listenRoom(code){
  onValue(ref(db, `rooms/${code}`),(snap)=>{
    const v=snap.val(); state.watching=v;
    if(v){ const p=Object.keys(v.players||{}).length, s=Object.keys(v.spectators||{}).length; if(p===0 && s===0){ remove(ref(db, `rooms/${code}`)); return; } }
    H(listsBox, !!v?.started);
    renderLists(v); renderItemsAndDi(v); renderTables(v); renderMissionPanels(v); renderGlobalReveal(v); renderHostTool(v);
    state.gameStarted=!!v?.started;
    H(btnStart, !(state.isHost && !state.gameStarted));
    H(startHint, !(state.isHost && !state.gameStarted));
    updateHeaderInfo();
  });
}

/* mission panels */
function renderMissionPanels(v){
  if(!v?.mission){
    missionTitle.textContent='（未選択）';
    missionText.textContent='開始時に人数と一緒に選びます';
    missionDetailTitle.textContent=''; missionDetailBody.innerHTML='';
    H(missionFooter,true); H(missionBox,false); return;
  }
  missionDetailTitle.textContent = v.mission.display?.[0] || '';
  missionDetailBody.innerHTML = (v.mission.display||[]).slice(1).map(line=>`<div class="line">${line}</div>`).join('');
  H(missionFooter, !v.started); H(missionBox, !!v.started);
}

/* lists */
function renderLists(v){
  playersEl.innerHTML=''; specsEl.innerHTML=''; if(!v) return;
  Object.values(v.players||{}).forEach(u=>{ const d=document.createElement('div'); d.className='name'; d.textContent=u.name||'(?)'; playersEl.appendChild(d); });
  Object.values(v.spectators||{}).forEach(u=>{ const d=document.createElement('div'); d.className='name muted'; d.textContent=u.name||'(?)'; specsEl.appendChild(d); });
}

/* ===== Items & DI ===== */
function renderItemsAndDi(v){
  if(!v || !v.started){ H(itemsBar,true); return; }
  H(itemsBar,false);

  itemsEl.innerHTML='';
  const itemNodes = []; // ★ ノード参照を保持

  (v.items||[]).forEach((it, idx)=>{
    const div=document.createElement('div'); div.className='item' + (it.used?' used':'');
    if(!it.used) div.style.backgroundImage = `url("./item${it.no}.jpg")`;

 // ★ 追加：アイテム16の情報トークンをカードの真下に表示
if(it.no===16 && v?.meta?.i16Badge && v.meta.i16Badge.num!=null){
  const below = document.createElement('div');
  below.className = 'i16-below';
  const tok = document.createElement('div');
  tok.className = 'token black';
  tok.textContent = String(v.meta.i16Badge.num);
  tok.title = 'クリックで操作';
  tok.onclick = (ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      {label:'消す', action: async ()=>{ await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: null }); }}
    ]);
  };
  below.appendChild(tok);
  div.appendChild(below);

  // 追加：カードを上に持ち上げて下のトークンがスクロールなしで見えるように
  div.classList.add('i16-lift');
}

    div.onclick=(ev)=>{
      if(it.used){
        openOneMini(ev.clientX, ev.clientY, '表にする', async ()=>{
          await update(ref(db, `rooms/${state.roomCode}/items/${idx}`), {used:false});
        });
      }else{
        openOneMini(ev.clientX, ev.clientY, '使用する', async ()=>{
          await update(ref(db, `rooms/${state.roomCode}/items/${idx}`), {used:true});
          const path=`rooms/${state.roomCode}/meta/itemUses`;
          const uses = state.watching?.meta?.itemUses || {i1:0,i2:0,i12:0,i14:0};
          if(it.no===1)  await update(ref(db, path), {i1:(uses.i1||0)+1});
          if(it.no===2)  await update(ref(db, path), {i2:(uses.i2||0)+1});
          if(it.no===12) await update(ref(db, path), {i12:(uses.i12||0)+1});
          if(it.no===14) await update(ref(db, path), {i14:(uses.i14||0)+1});

          if(it.no===2){
            await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:{usingBy:state.userId, phase:'pickSelf', selA:null, selB:null} });
          }
          if(it.no===13){ await addTwoItemsFromDeck(); }
          if(it.no===16){ await handleItem16(idx); }
          if(it.no===18){ await update(ref(db, `rooms/${state.roomCode}/meta`), { i18Flow:{usingBy:state.userId, phase:'pickOther', sel:null} }); }
        });
      }
    };

    itemsEl.appendChild(div);
    itemNodes.push(div);
  });


  const val = clamp(v.di?.value ?? v.tableCount, 0, 6);
  diEl.style.backgroundImage = `url("./di${val}.png")`;
  diEl.onclick=(ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      {label:'進める', action: async ()=>{ const nowv=state.watching?.di?.value ?? val; const next=clamp(nowv-1,0,6); await update(ref(db, `rooms/${state.roomCode}/di`), {value:next}); }},
      {label:'戻す', action: async ()=>{ const nowv=state.watching?.di?.value ?? val; const next=clamp(nowv+1,0,6); await update(ref(db, `rooms/${state.roomCode}/di`), {value:next}); }},
    ]);
  };
}

/* ===== Global badge (item16) ===== */
function renderGlobalReveal(v){
  // 変更：サイド表示に切り替えたため常に非表示
  globalReveal.innerHTML='';
  H(globalReveal,true);
}

/* ===== Host tool (odd-open normal codes) ===== */
function renderHostTool(v){
  if(!v?.tables){ H(hostTool,true); return; }
  const openCountByNum = {};
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      if(c?.kind==='normal' && c.open===true){
        const n = c.num|0;
        openCountByNum[n] = (openCountByNum[n]||0) + 1;
      }
    });
  });
  const hasOdd = Object.values(openCountByNum).some(cnt => (cnt % 2)===1);
  H(hostTool, !hasOdd);
}
hostTool.onclick = ()=> alert('全体公開されている通常コードの枚数に奇数が含まれています。');

/* ===== Tables ===== */
function renderTables(v){
  tablesEl.innerHTML=''; if(!v) return;

  const W = cssNum('--card-w'), G = cssNum('--card-gap'), CW = cssNum('--char-w');
  const seatedAny = (v.tables||[]).some(T => !!T.playerId);

  // ★ 変更：上限の対応
  //   ＝ の上限はアイテム12の使用回数
  //   ≠ の上限はアイテム1の使用回数
  const uses = v.meta?.itemUses || {i1:0,i2:0,i12:0,i14:0};
  const caps = { 
    equal: uses.i12>=2 ? 4 : (uses.i12>=1 ? 2 : 0),
    noteq: uses.i1>=2  ? 4 : (uses.i1>=1  ? 2 : 0),
    x1:    uses.i14>=2 ? 2 : (uses.i14>=1 ? 1 : 0)
  };
  const counts = v.meta?.tokenCounts || {equal:0,noteq:0,x1:0};
  const i2All=v.meta?.i2Flow;
  const i18All=v.meta?.i18Flow;

  (v.tables||[]).forEach((t, idx)=>{
    const box=document.createElement('div'); box.className='table';
    box.addEventListener('mouseenter', ()=> box.classList.add('elevated'));
    box.addEventListener('mouseleave', ()=> {
      const hasTokenLater = (t.hand||[]).some(c=> (c.tokens||[]).length>0);
      if(!hasTokenLater) box.classList.remove('elevated');
    });

    const n = (t.hand||[]).length;
    const handInner = n>0 ? (n*W + (n-1)*G) : 0;
    const totalW = CW + 8 + handInner + 16;
    box.style.width = Math.max(totalW, CW + 16) + 'px';

    const header=document.createElement('div'); header.className='t-header';
    const title=document.createElement('div');  title.className='title';
    title.textContent = t.playerName ? t.playerName : String(t.titleNumber ?? (idx+1));
    header.appendChild(title); box.appendChild(header);

    const content=document.createElement('div'); content.className='t-content';

    const char=document.createElement('div'); char.className='char-card';
    if(!seatedAny){ char.classList.add('blank'); }
    else{
      const face = t.character?.flipped ? './battery.jpg' : `./${t.character?.face || 'member (1).jpg'}`;
      char.style.backgroundImage = `url("${face}")`;
      char.onclick=async ()=>{ await update(ref(db, `rooms/${state.roomCode}/tables/${idx}/character`), {flipped: !t.character?.flipped}); };
    }
    content.appendChild(char);

    const hand=document.createElement('div'); hand.className='hand';
    (t.hand||[]).forEach((c,ci)=>{
      const wrap=document.createElement('div'); wrap.className='card-wrap';
      const card=document.createElement('div'); card.className='card';
      const isMine = c.ownerId === state.userId;
      if(!isMine && !c.open) card.classList.add('back');
      if(c.open) card.classList.add('open');

      if (i2All?.selA && i2All.selA.cardId===c.id && i2All.selA.table===idx){ const m = document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if (i2All?.selB && i2All.selB.cardId===c.id && i2All.selB.table===idx){ const m = document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if (i18All?.sel && i18All.sel.cardId===c.id && i18All.sel.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if(c.markUntil && now()<c.markUntil){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }

      const isI2Actor = i2All && i2All.usingBy===state.userId;
      const canPickSelf  = isI2Actor && i2All?.phase==='pickSelf'  && t.playerId===state.userId;
      const canPickOther = isI2Actor && i2All?.phase==='pickOther' && t.playerId!==state.userId;

      const isI18Actor = i18All && i18All.usingBy===state.userId;
      const canI18Pick = isI18Actor && i18All?.phase==='pickOther' && t.playerId!==state.userId;

      if(isI2Actor && (canPickSelf || canPickOther)){
        card.classList.add('i2-selectable');
        card.onclick = async (ev)=>{
          ev.stopPropagation();
          if(canPickSelf){
            await update(ref(db, `rooms/${state.roomCode}/meta/i2Flow`), { selA:{table:idx, cardId:c.id}, phase:'pickOther' });
          }else if(canPickOther){
            await update(ref(db, `rooms/${state.roomCode}/meta/i2Flow`), { selB:{table:idx, cardId:c.id} });
            openBottomMenu([
              {label:'交換する', action: async ()=>{
                const i2 = (await get(ref(db, `rooms/${state.roomCode}/meta/i2Flow`))).val();
                if(i2?.selA && i2?.selB) await doItem2Swap(i2.selA, i2.selB);
              }},
              {label:'やり直す', action: async ()=>{
                await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:{usingBy:state.userId, phase:'pickSelf', selA:null, selB:null} });
              }}
            ]);
          }
        };
      }else if(canI18Pick){
        card.classList.add('i2-selectable');
        card.onclick = async (ev)=>{
          ev.stopPropagation();
          await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), { sel:{table:idx, cardId:c.id} });
          openBottomMenu([
            {label:'とる', action: async ()=>{ const i18=(await get(ref(db, `rooms/${state.roomCode}/meta/i18Flow`))).val(); if(i18?.sel) await doItem18Take(i18.sel); }},
            {label:'やり直す', action: async ()=>{ await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), { sel:null, phase:'pickOther' }); }}
          ]);
        };
      }else{
        card.onclick = async ()=>{
          if(isMine){
            const blockingI2 = i2All && i2All.usingBy===state.userId && (i2All.phase==='pickSelf' || i2All.phase==='pickOther');
            const blockingI18= i18All && i18All.usingBy===state.userId && (i18All.phase==='pickOther');
            if(blockingI2 || blockingI18) return;
            await update(ref(db, `rooms/${state.roomCode}/tables/${idx}/hand/${ci}`), {open: !c.open});
          }
        };
      }

      const num=document.createElement('div'); num.className='num';
      num.textContent=String(c.num);
      num.style.visibility = (c.open || isMine) ? 'visible' : 'hidden';
      card.appendChild(num);

      const bot=document.createElement('div'); bot.className='img-bottom';
      let img='codenumber.jpg'; if(c.kind==='red') img='redcode.png'; if(c.kind==='yellow') img='yellowcode.png';
      bot.style.backgroundImage=`url("./${img}")`; if(card.classList.contains('back')) bot.style.display='none';
      card.appendChild(bot);

      const badge=document.createElement('div'); badge.className='badge-fixed';
      const a=document.createElement('div'); a.className='alpha'; a.textContent=c.alpha||'';

      const col=document.createElement('div'); col.className='tok-col';
      (c.tokens||[]).forEach(tk=>{
        const el=document.createElement('div'); el.className='token ' + (tk.style||'');
        col.appendChild(el);
        el.textContent =
          tk.type==='equal' ? '＝' :
          tk.type==='noteq' ? '≠' :
          tk.type==='x1'    ? 'x1' :
          tk.type==='num'   ? tk.value : '';
      });

      if(!(i2All && i2All.usingBy===state.userId) && !(i18All && i18All.usingBy===state.userId) && isMine){
        a.onclick=(ev)=>{
          ev.stopPropagation();
          const cardPath  = `rooms/${state.roomCode}/tables/${idx}/hand/${ci}`;
          const tokens = c.tokens || [];
          const has = (type)=> tokens.some(tk=>tk.type===type);

          const canEqual = !has('equal') && (counts.equal < caps.equal);
          const canNoteq = !has('noteq') && (counts.noteq < caps.noteq);
          const canNum   = !has('num');
          const canX1    = !has('x1') && (counts.x1 < caps.x1);

          const entries = [];

          if(canNum){
            entries.push({label:String(c.num), action: async ()=>{
              const updated=[...(tokens), {type:'num', value:c.num, style:'black'}];
              await update(ref(db, cardPath), { tokens: updated });
              box.classList.add('elevated');
            }});
          }

          // ＝（アイテム12管理）
          if (has('equal')) {
            entries.push({
              label:'＝',
              action: async ()=>{
                openMenu(ev.clientX, ev.clientY, [
                  { label:'消す', action: async ()=>{
                      const next = tokens.filter(tk=>tk.type!=='equal');
                      await update(ref(db, cardPath), { tokens: next });
                      await incToken('equal', -1);
                      const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                      box.classList.toggle('elevated', afterHas);
                    }},
                  { label:String(c.num), action: async ()=>{
                      if(!has('num')){
                        const next=[...(tokens), {type:'num', value:c.num, style:'black'}];
                        await update(ref(db, cardPath), { tokens: next });
                        box.classList.add('elevated');
                      }
                    }}
                ]);
              }
            });
          } else if (canEqual){
            entries.push({label:'＝', action: async ()=>{
              const updated=[...(tokens), {type:'equal', value:c.num, style:'equal'}];
              await update(ref(db, cardPath), { tokens: updated });
              await incToken('equal', +1);
              box.classList.add('elevated');
            }});
          }

          // ≠（アイテム1管理）
          if (has('noteq')) {
            entries.push({
              label:'≠',
              action: async ()=>{
                openMenu(ev.clientX, ev.clientY, [
                  { label:'消す', action: async ()=>{
                      const next = tokens.filter(tk=> tk.type!=='noteq');
                      await update(ref(db, cardPath), { tokens: next });
                      await incToken('noteq', -1);
                      const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                      box.classList.toggle('elevated', afterHas);
                    }},
                  { label:String(c.num), action: async ()=>{
                      if(!has('num')){
                        const next=[...(tokens), {type:'num', value:c.num, style:'black'}];
                        await update(ref(db, cardPath), { tokens: next });
                        box.classList.add('elevated');
                      }
                    }}
                ]);
              }
            });
          } else if (canNoteq){
            entries.push({
              label:'≠',
              action: async ()=>{
                const updated=[...(tokens), {type:'noteq', value:c.num, style:'noteq'}];
                await update(ref(db, cardPath), { tokens: updated });
                await incToken('noteq', +1);
                box.classList.add('elevated');
              }
            });
          }

          if(canX1){
            entries.push({label:'x1', action: async ()=>{
              const updated=[...(tokens), {type:'x1', value:c.num, style:'x1'}];
              await update(ref(db, cardPath), { tokens: updated });
              await incToken('x1', +1);
              box.classList.add('elevated');
            }});
          }
          if(has('x1')){
            entries.push({label:'x1', action: async ()=>{
              openMenu(ev.clientX, ev.clientY, [
                {label:'消す', action: async ()=>{
                  const next = tokens.filter(tk=>tk.type!=='x1');
                  await update(ref(db, cardPath), { tokens: next });
                  await incToken('x1', -1);
                  const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                  box.classList.toggle('elevated', afterHas);
                }},
                {label:String(c.num), action: async ()=>{
                  if(!has('num')){
                    const next=[...(tokens), {type:'num', value:c.num, style:'black'}];
                    await update(ref(db, cardPath), { tokens: next });
                    box.classList.add('elevated');
                  }
                }},
              ]);
            }});
          }

          if(tokens.length>0){
            tokens.forEach((tk,ti)=>{
              const label = tk.type==='equal' ? '＝を消す' : tk.type==='noteq' ? '≠を消す' : tk.type==='x1' ? 'x1を消す' : '数字を消す';
              entries.push({label, action: async ()=>{
                const next = tokens.slice(); const removed = next.splice(ti,1)[0];
                await update(ref(db, cardPath), { tokens: next });
                if(removed?.type==='equal') await incToken('equal', -1);
                if(removed?.type==='noteq') await incToken('noteq', -1);
                if(removed?.type==='x1')    await incToken('x1', -1);
                const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                box.classList.toggle('elevated', afterHas);
              }});
            });
          }

          openMenu(ev.clientX, ev.clientY, entries);
        };
      }

      badge.appendChild(a);
      badge.appendChild(col);

      wrap.appendChild(card);
      wrap.appendChild(badge);
      hand.appendChild(wrap);
    });
    content.appendChild(hand);
    box.appendChild(content);

    const hasToken = (t.hand||[]).some(c=> (c.tokens||[]).length>0);
    box.classList.toggle('elevated', hasToken);

    tablesEl.appendChild(box);
  });

  async function incToken(kind, delta){
    const path = `rooms/${state.roomCode}/meta/tokenCounts`;
    const nowv = (state.watching?.meta?.tokenCounts||{})[kind]||0;
    await update(ref(db, path), {[kind]: Math.max(0, nowv + delta)});
  }
}

/* ===== Item 2 swap ===== */
async function doItem2Swap(A, B){
  if(!A || !B) return;
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || [];

  const pickCard = (tableIdx, cardId)=>{
    const hand = (tables[tableIdx]?.hand)||[];
    const i = hand.findIndex(c=> c.id===cardId);
    return {hand, index:i, card: i>=0 ? hand[i] : null};
  };

  const a = pickCard(A.table, A.cardId);
  const b = pickCard(B.table, B.cardId);
  if(!a.card || !b.card){ await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:null }); return; }

  a.hand.splice(a.index,1); b.hand.splice(b.index,1);

  const insertSortedLeft = (hand, card)=>{ const n = card.num; let pos = 0; while(pos<hand.length && hand[pos].num < n) pos++; while(pos>0 && hand[pos-1].num===n) pos--; hand.splice(pos,0,card); };

  const mark = now()+10000; // 10秒
  const toB = {...a.card, ownerId: tables[B.table].playerId || null, markUntil: mark};
  const toA = {...b.card, ownerId: tables[A.table].playerId || null, markUntil: mark};

  insertSortedLeft(b.hand, toB);
  insertSortedLeft(a.hand, toA);

  const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };
  realpha(a.hand); realpha(b.hand);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/tables/${A.table}/hand`), a.hand),
    set(ref(db, `rooms/${state.roomCode}/tables/${B.table}/hand`), b.hand),
    update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:null })
  ]);
}

/* ===== Item 18 take ===== */
async function doItem18Take(sel){
  const myTable = state.watching?.tables?.findIndex(t=> t.playerId===state.userId);
  if(myTable==null || myTable<0){ alert('席に座ってから使用してください'); await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), {sel:null, phase:'pickOther'}); return; }
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || [];

  const srcHand = (tables[sel.table]?.hand)||[];
  const si = srcHand.findIndex(c=> c.id===sel.cardId);
  if(si<0){ await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), {sel:null, phase:'pickOther'}); return; }
  const card = srcHand.splice(si,1)[0];

  const dstHand = (tables[myTable]?.hand)||[];
  const n = card.num;
  let pos = 0; while(pos<dstHand.length && dstHand[pos].num < n) pos++; while(pos>0 && dstHand[pos-1].num===n) pos--; 
  const mark = now()+10000;
  dstHand.splice(pos,0,{...card, ownerId: state.userId, markUntil: mark});

  const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };
  realpha(dstHand); realpha(srcHand);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/tables/${sel.table}/hand`), srcHand),
    set(ref(db, `rooms/${state.roomCode}/tables/${myTable}/hand`), dstHand),
    update(ref(db, `rooms/${state.roomCode}/meta`), { i18Flow:null })
  ]);
}

/* ===== Item helpers ===== */
function itemDeckNumbers(){
  return Array.from({length:18}, (_,i)=> i+1);
}

/* item13: 追加で2枚 */
async function addTwoItemsFromDeck(){
  const v = state.watching; if(!v) return;
  const pool = itemDeckNumbers();
  const existingNos = new Set((v.items||[]).map(i=>i.no));
  const candidates = pool.filter(n=> !existingNos.has(n));
  shuffle(candidates);
  const pick = candidates.slice(0,2).map(no=>({id:crypto.randomUUID(), no, used:false}));
  const next = (v.items||[]).concat(pick);
  await set(ref(db, `rooms/${state.roomCode}/items`), next);
}

/* item16: 数字(1..12)の使用数を集計し、<2の数字から1つ選びメタに保存（表示はアイテム16右側で行う） */
async function handleItem16(itemIdx){
  const v = state.watching; if(!v) return;

  const counts = Array.from({length:13}, ()=>0); // 1..12
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      (c.tokens||[]).forEach(tk=>{
        if(tk?.type==='num'){
          const n = parseInt(tk.value, 10);
          if(n>=1 && n<=12) counts[n] += 1;
        }
      });
    });
  });

  const candidates = [];
  for(let n=1; n<=12; n++){
    if((counts[n]||0) < 2) candidates.push(n);
  }

  if(candidates.length===0){
    await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: null });
    return;
  }

  const pick = candidates[Math.floor(Math.random()*candidates.length)];
  await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: { num: pick, at: Date.now() } });
}

/* gear etc */
function updateMenuButtons(){ const seated = state.seatedTable!=null; H(btnSit, seated); H(btnLeave, !seated); }
const outsideClose=(e,t)=>{ if(!t.contains(e.target)) H(t,true); };
function closeAllMini(e){ document.querySelectorAll('.mini-pop').forEach(pop=>{ if(!pop.contains(e.target)) pop.remove(); }); }
 document.addEventListener('click',(e)=>{ closeAllMini(e); outsideClose(e, menuPop); }, true);
gear.onclick=()=> { menuPop.classList.toggle('hidden'); if(!menuPop.classList.contains('hidden')) updateMenuButtons(); };

/* ★ 共通の離席処理 */
async function leaveSeatNow(){
  if(state.seatedTable==null || !state.watching?.tables) return;
  const idx=state.seatedTable; const hand=(state.watching.tables[idx].hand||[]);
  await update(ref(db, `rooms/${state.roomCode}/tables/${idx}`), {playerId:null, playerName:null});
  await Promise.all(hand.map((_,i)=> update(ref(db, `rooms/${state.roomCode}/tables/${idx}/hand/${i}`), {ownerId:null})));
  state.seatedTable=null; updateMenuButtons();
}

btnSit.onclick = ()=>{
  if(state.mode!=='player'){ alert('観戦入室では席に座れません。参加で入り直してください。'); return; }
  const v=state.watching; if(!v?.started){ alert('ゲーム開始後に席を選べます'); return; }
  seatTabs.innerHTML='';
  (v.tables||[]).forEach((t,i)=>{
    const tab=document.createElement('div'); tab.className='tab';
    tab.textContent = t.playerName ? `${i+1}（使用中）` : `${i+1}`;
    if(t.playerId) tab.classList.add('disabled');
    tab.onclick=async ()=>{
      if(tab.classList.contains('disabled')) return;
      await update(ref(db, `rooms/${state.roomCode}/tables/${i}`), {playerId:state.userId, playerName:state.userName});
      const hand=(v.tables[i].hand||[]);
      await Promise.all(hand.map((_,idx)=> update(ref(db, `rooms/${state.roomCode}/tables/${i}/hand/${idx}`), {ownerId:state.userId})));
      state.seatedTable=i; H(seatPop,true); updateMenuButtons();
    };
    seatTabs.appendChild(tab);
  });
  H(seatPop,false);
};
btnSeatCancel.onclick=()=> H(seatPop,true);

btnLeave.onclick = async ()=>{ await leaveSeatNow(); };

/* start/restart */
btnRestart.onclick = ()=>{ if(!state.isHost){ alert('ホストのみ操作可'); return; } H(restartPop,false); };
btnRestartOk.onclick = async ()=>{
  H(restartPop,true);
  /* ★ ミッション「やり直す」確定時に自動で席を立つ */
  await leaveSeatNow();
  const v=state.watching; if(!v) return;
  await startGame(v.tableCount || 4, v.mission?.id || 1);
};
btnRestartCancel.onclick = ()=> H(restartPop,true);
btnStart.onclick = ()=>{ if(!state.isHost) return; H(startPop,false); };
btnStartCancel.onclick = ()=> H(startPop,true);
btnStartOk.onclick = async ()=>{ const count=clamp(parseInt(selCount.value,10),1,6); const missionId=parseInt(selMission.value,10); H(startPop,true); await startGame(count, missionId); };

async function startGame(playerCount, missionId){
  if(!state.isHost) return;
  const code=state.roomCode;

  const captainIndex = Math.floor(Math.random()*playerCount);
  const faces=[1,2,3,4]; shuffle(faces);
  const tables=[]; for(let i=0;i<playerCount;i++){ const face=(i===captainIndex)?'member (5).jpg':`member (${faces[i%4]}).jpg`; tables.push({ titleNumber:i+1, playerId:null, playerName:null, character:{face, flipped:false}, hand:[] }); }

  // ===== デッキ構築 =====
  let deck=[]; let missionMeta;
  // ベースデッキ 1..12 x4 = 48（通常コード）
  const base=[]; for(let n=1;n<=12;n++){ for(let k=0;k<4;k++) base.push({id:crypto.randomUUID(), num:n, kind:'normal', open:false, ownerId:null}); }
  shuffle(base);

  if(missionId===1){
    // ★ 赤コード（1.5,2.5,...,11.5）から1枚
    const x = (Math.random()*11|0) + 1; // 1..11
    const specialNum = x + 0.5;
    const special = { id:crypto.randomUUID(), num:specialNum, kind:'red', open:false, ownerId:null };
    deck = base.concat([special]);
    shuffle(deck);
    missionMeta = missionInfo(1, specialNum);
  }else if(missionId===2){
    // ★ 黄コード（1.1,2.1,...,11.1）から1枚
    const x = (Math.random()*11|0) + 1; // 1..11
    const specialNum = x + 0.1;
    const special = { id:crypto.randomUUID(), num:specialNum, kind:'yellow', open:false, ownerId:null };
    deck = base.concat([special]);
    shuffle(deck);
    missionMeta = missionInfo(2, specialNum);
  }else{
    deck = base; // 通常
    missionMeta = missionInfo(missionId);
  }

  // ===== 配布 → 手札昇順 → α付与 =====
  const alpha="abcdefghijklmnopqrstuvwxyz";
  let p=0; while(p<deck.length){ for(let t=0; t<playerCount && p<deck.length; t++){ const c=deck[p++]; tables[t].hand.push({...c, alpha:'', tokens:[], markUntil:null}); } }
  tables.forEach(T=>{ T.hand.sort((a,b)=> a.num - b.num); T.hand.forEach((c,i)=>{ c.alpha = alpha[i % alpha.length]; }); });

  // アイテム（人数ぶん）
  const pool = itemDeckNumbers(); shuffle(pool);
  const items = pool.slice(0, Math.min(playerCount, pool.length)).map(no=>({id:crypto.randomUUID(),no,used:false}));

  await set(ref(db, `rooms/${code}`), {
    ...(state.watching||baseRoom(state.userId)),
    hostId: state.watching?.hostId || state.userId,
    started:true, tableCount:playerCount, tables, items,
    di:{value:playerCount, max:6}, captainTable: captainIndex, mission: missionMeta,
    meta:{ itemUses:{i1:0,i2:0,i12:0,i14:0}, tokenCounts:{equal:0,noteq:0,x1:0}, i2Flow:null, i18Flow:null, i16Badge:null }
  });

  H(gear,false);
}

function missionInfo(id, x=null){
  // 表示も新定義に合わせる
  switch(id){
    case 1:{ // 赤コード
      const dispX = (x!=null) ? x : ((Math.random()*11|0)+1)+0.5;
      return {id:1, name:'爆弾（赤）', desc:'赤コードが1つ', display:[`#1 爆弾（赤コード）`, `${dispX} が1つ`, '通常：1～12 / 赤：1.5～11.5 / 黄：1.1～11.1']};
    }
    case 2:{ // 黄コード
      const dispX = (x!=null) ? x : ((Math.random()*11|0)+1)+0.1;
      return {id:2, name:'黄コード', desc:'黄コードが1つ', display:[`#2 黄コード`, `${dispX} が1つ`, '通常：1～12 / 赤：1.5～11.5 / 黄：1.1～11.1']};
    }
    case 3:{
      // 例：赤系の候補から3つ提示（必要ならここも調整可）
      const list=[1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5]; shuffle(list);
      const pick=list.slice(0,3);
      return {id:3, name:'さらい爆弾', desc:'x – y – z のうち1つ', display:[`#3 さらい爆弾`, `${pick[0]} – ${pick[1]} - ${pick[2]} のうち1つ`, '通常：1～12 / 赤：1.5～11.5 / 黄：1.1～11.1']};
    }
    case 42:{ return {id:42, name:'#42', desc:'特殊なし', display:['#42','特殊なし']}; }
    case 43:{ return {id:43, name:'#43', desc:'特殊なし', display:['#43','特殊なし']}; }
    default: return {id, name:`#${id}`, desc:'', display:[`#${id}`]};
  }
}

// 画面タップで各種ポップは外側タップで消える
 document.addEventListener('click',(e)=>{ if(!miniPop.contains(e.target)) H(miniPop,true); }, true);
</script>
</body>
</html>
